# -*- coding: utf-8 -*-
"""Proyek Akhir Machine Learning Terapan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NgUqc9oLF_mqkwwPXKwfuCULPlBEL1P2

#Sistem Rekomendasi Anime - Laporan Proyek Machine Learning

#Project Overview

Sistem rekomendasi telah menjadi komponen penting dalam berbagai platform digital, terutama layanan streaming dan database konten seperti MyAnimeList, Netflix, Crunchyroll, dan layanan serupa. Sistem ini membantu pengguna menemukan konten yang relevan dengan selera mereka di tengah banyaknya pilihan yang tersedia. Dalam konteks anime, dengan ribuan judul yang tersedia dan terus bertambah setiap musimnya, sistem rekomendasi menjadi krusial untuk meningkatkan pengalaman pengguna dan membantu mereka menemukan anime baru yang potensial disukai berdasarkan preferensi mereka sebelumnya.
Menurut penelitian yang dilakukan oleh Grand View Research, industri animasi dan manga global diperkirakan bernilai sekitar $25 miliar pada tahun 2020 dan diproyeksikan terus tumbuh. Dari segi konsumsi konten, menurut laporan Parrot Analytics, permintaan untuk anime secara global meningkat sebesar 33% antara tahun 2020 dan 2021. Fenomena ini menjadikan sistem rekomendasi anime tidak hanya sebagai fitur tambahan, tetapi juga sebagai komponen strategis untuk meningkatkan engagement pengguna dan mendorong pertumbuhan platform.

Proyek ini penting untuk diselesaikan karena:

1. Membantu pengguna menemukan konten yang sesuai dengan preferensi mereka di tengah banyaknya pilihan anime yang tersedia
2. Meningkatkan pengalaman pengguna pada platform anime, yang berpotensi meningkatkan retensi pengguna
3. Memperluas wawasan pengguna dengan merekomendasikan anime yang mungkin tidak akan mereka temukan sendiri
4. Memaksimalkan efisiensi konsumsi konten dengan mengurangi waktu yang dihabiskan untuk mencari anime yang sesuai dengan selera pengguna

Beberapa penelitian sebelumnya seperti yang dilakukan oleh Jannach et al. (2019) dalam "Recommender Systems: An Introduction" menunjukkan bahwa sistem rekomendasi yang efektif dapat meningkatkan tingkat konversi hingga 5.9% dan engagement pengguna hingga 12.5%. Dalam konteks anime, penelitian oleh Ping West et al. dalam "Content-Based Filtering Algorithm for Anime Recommendation Systems" (2018) menunjukkan bahwa pendekatan content-based filtering menghasilkan rekomendasi yang relevan dengan akurasi 78% berdasarkan kesamaan genre dan karakteristik anime.

#Business Understanding
**Problem Statements**

Berdasarkan latar belakang di atas, berikut adalah rumusan masalah yang akan diselesaikan dalam proyek ini:

1. Bagaimana cara mengembangkan sistem rekomendasi anime yang akurat berdasarkan preferensi pengguna?
2. Bagaimana membuat sistem rekomendasi yang dapat mempertimbangkan fitur-fitur penting dalam anime seperti genre, tipe, dan rating?
3. Bagaimana cara mengukur efektivitas dari sistem rekomendasi anime yang dikembangkan?

**Goals**

Tujuan dari proyek ini adalah:
1. Mengembangkan sistem rekomendasi anime yang dapat memberikan rekomendasi anime yang sesuai dengan preferensi pengguna
2. Mengimplementasikan dan membandingkan dua pendekatan sistem rekomendasi (Content-based Filtering dan Collaborative Filtering)
3. Mengukur dan mengevaluasi performa dari kedua pendekatan sistem rekomendasi yang dikembangkan

**Solution Approach**

Untuk mencapai tujuan yang telah ditentukan, proyek ini akan mengimplementasikan dua pendekatan sistem rekomendasi:

1. Content-based Filtering

- Pendekatan ini akan menganalisis konten atau atribut dari anime yang disukai pengguna dan merekomendasikan anime lain dengan atribut serupa
- Menggunakan fitur seperti genre, tipe, dan rating sebagai basis untuk menghitung kesamaan antar anime
- Mengimplementasikan teknik TF-IDF untuk mengekstraksi fitur dari data genre
- Menggunakan cosine similarity untuk menghitung tingkat kesamaan antara anime
- Kelebihan pendekatan ini adalah kemampuannya memberikan rekomendasi untuk pengguna baru tanpa memerlukan data rating dari pengguna lain (cold start problem)


2. Collaborative Filtering

- Pendekatan ini akan merekomendasikan anime berdasarkan preferensi pengguna lain yang memiliki pola rating serupa
- Menggunakan metode matrix factorization dengan teknik Singular Value Decomposition (SVD) untuk memprediksi rating pengguna terhadap anime yang belum mereka tonton
- Membangun model dengan bantuan library Surprise untuk implementasi teknik collaborative filtering
- Pendekatan ini efektif untuk menemukan rekomendasi yang tidak terlihat secara langsung dari fitur konten, namun memerlukan data interaksi pengguna yang cukup



Kedua pendekatan ini akan diimplementasikan dan dibandingkan untuk memberikan perspektif yang komprehensif tentang efektivitas sistem rekomendasi anime.
"""

!pip install numpy==1.26.4

# Import library yang diperlukan
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from surprise import Dataset, Reader, SVD
from surprise.model_selection import train_test_split
from surprise import accuracy
import warnings
warnings.filterwarnings('ignore')

# Load data
anime = pd.read_csv('/content/anime.csv')
rating = pd.read_csv('/content/rating.csv')

# Display basic information
print("Anime Dataset Info:")
print(anime.info())
print("\nRating Dataset Info:")
print(rating.info())

# Basic exploratory analysis
print("\nAnime Dataset Sample:")
print(anime.head())
print("\nRating Dataset Sample:")
print(rating.head())

# Check for missing values
print("\nMissing values in Anime Dataset:")
print(anime.isnull().sum())
print("\nMissing values in Rating Dataset:")
print(rating.isnull().sum())

"""##Data Understanding
Dataset yang digunakan dalam proyek ini berasal dari Kaggle, yang berisi informasi anime dan rating pengguna. Dataset ini terdiri dari dua file:

1. Anime.csv - Informasi tentang anime
2. Rating.csv - Rating yang diberikan pengguna untuk anime tertentu

**Anime Dataset**
Dataset anime berisi informasi tentang berbagai anime, dengan atribut sebagai berikut:

- anime_id: ID unik untuk setiap anime
- name: Judul anime
- genre: Genre anime (dapat berisi beberapa genre yang dipisahkan dengan koma)
- type: Tipe anime (TV, Movie, OVA, dll)
episodes: Jumlah episode
- rating: Rating rata-rata anime
- members: Jumlah anggota komunitas yang telah menambahkan anime ke daftar mereka.

**Link Dataset** =
https://www.kaggle.com/datasets/CooperUnion/anime-recommendations-database
"""

# Data visualization
plt.figure(figsize=(10, 6))
sns.histplot(anime['rating'].dropna(), kde=True)
plt.title('Distribusi Rating Anime')
plt.xlabel('Rating')
plt.ylabel('Jumlah Anime')
plt.show()

# Distribution of anime types
plt.figure(figsize=(12, 6))
sns.countplot(y='type', data=anime, order=anime['type'].value_counts().index[:10])
plt.title('10 Tipe Anime Terpopuler')
plt.xlabel('Jumlah Anime')
plt.ylabel('Tipe')
plt.show()

# Extract and visualize genres
all_genres = []
for genres in anime['genre'].dropna():
    all_genres.extend(genres.split(', '))

genre_counts = pd.Series(all_genres).value_counts()

plt.figure(figsize=(12, 8))
sns.barplot(x=genre_counts.values[:15], y=genre_counts.index[:15])
plt.title('15 Genre Anime Terpopuler')
plt.xlabel('Jumlah Anime')
plt.ylabel('Genre')
plt.show()


# Rating distribution
plt.figure(figsize=(10, 6))
sns.countplot(x='rating', data=rating)
plt.title('Distribusi Rating dari Pengguna')
plt.xlabel('Rating')
plt.ylabel('Jumlah')
plt.show()

"""Dari eksplorasi data ini, kita mendapatkan beberapa insight:

1. Mayoritas anime memiliki rating 8,Terdapat nilai rating -1, yang kemungkinan menandakan anime yang telah ditonton tetapi tidak diberi rating
2. Tipe anime yang paling umum adalah TV series, diikuti oleh OVA dan Movie
3. Genre yang paling populer adalah Comedy, Action, dan Adventure

##Data Preparation
Sebelum membuat model rekomendasi, perlu dilakukan beberapa langkah persiapan data untuk memastikan kualitas data dan kesesuaiannya dengan algoritma yang akan digunakan.
"""

##Data preparation

# Handle missing values in anime dataset
anime_cleaned = anime.copy()
anime_cleaned['genre'] = anime_cleaned['genre'].fillna('Unknown')
anime_cleaned['type'] = anime_cleaned['type'].fillna('Unknown')
anime_cleaned = anime_cleaned.dropna(subset=['rating'])

# Handle invalid ratings in rating dataset
rating_cleaned = rating.copy()
rating_cleaned = rating_cleaned[rating_cleaned['rating'] > 0]

# Filter data for computational efficiency
user_counts = rating_cleaned['user_id'].value_counts()
active_users = user_counts[user_counts >= 50].index

anime_counts = rating_cleaned['anime_id'].value_counts()
popular_anime = anime_counts[anime_counts >= 100].index

rating_filtered = rating_cleaned[
    (rating_cleaned['user_id'].isin(active_users)) &
    (rating_cleaned['anime_id'].isin(popular_anime))
]

print(f"Jumlah data rating setelah filtering: {len(rating_filtered)}")
print(f"Jumlah pengguna unik setelah filtering: {rating_filtered['user_id'].nunique()}")
print(f"Jumlah anime unik setelah filtering: {rating_filtered['anime_id'].nunique()}")

"""Langkah ini penting untuk memastikan bahwa tidak ada nilai yang hilang pada kolom yang akan digunakan untuk membuat sistem rekomendasi. Missing values pada genre dan type diganti dengan "Unknown" alih-alih menghapusnya karena anime tersebut masih memiliki informasi lain yang berguna. Sedangkan anime tanpa rating dihapus karena rating merupakan fitur penting untuk sistem rekomendasi.

Penghapusan rating -1 dilakukan karena nilai tersebut tidak menunjukkan preferensi pengguna yang sebenarnya (merupakan indikasi anime yang telah ditonton tetapi tidak diberi rating), sehingga dapat membiaskan model collaborative filtering.

Langkah filtering ini dilakukan untuk:

1. Mengurangi sparsity dalam matriks user-item dengan hanya mempertimbangkan pengguna aktif dan anime populer
2. Mengurangi computational complexity untuk model collaborative filtering
3. Meningkatkan kualitas rekomendasi dengan fokus pada data yang lebih representatif
"""

# Content-based Filtering

# Filter anime in ratings dataset
anime_in_ratings = anime_cleaned[anime_cleaned['anime_id'].isin(rating_filtered['anime_id'].unique())]


anime_in_ratings = anime_in_ratings.reset_index(drop=True)

# Create TF-IDF matrix for genres
tfidf = TfidfVectorizer(tokenizer=lambda x: x.split(', '))
tfidf_matrix = tfidf.fit_transform(anime_in_ratings['genre'])
print(f"Bentuk matriks TF-IDF: {tfidf_matrix.shape}")

# Calculate cosine similarity
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Create mapping of anime_id to index
indices = pd.Series(anime_in_ratings.index, index=anime_in_ratings['anime_id']).drop_duplicates()

# Function to get content-based recommendations
def get_content_based_recommendations(anime_id, cosine_sim=cosine_sim, anime_df=anime_in_ratings, indices=indices):
    # Get index of the anime
    idx = indices[anime_id]

    # Get similarity scores
    sim_scores = list(enumerate(cosine_sim[idx]))

    # Sort anime by similarity
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get top 10 similar anime (excluding itself)
    sim_scores = sim_scores[1:11]

    # Get anime indices
    anime_indices = [i[0] for i in sim_scores]

    # Return top 10 most similar anime
    recommendations = anime_df.iloc[anime_indices][['anime_id', 'name', 'genre', 'type', 'rating']]
    return recommendations

"""Penggunaan TF-IDF untuk encoding genre dilakukan karena:

1. TF-IDF dapat memperhitungkan kepentingan setiap genre dalam anime
2. Memungkinkan perhitungan similarity yang lebih akurat dibandingkan one-hot encoding sederhana
3. Dapat menangani multiple genres untuk satu anime dengan baik
"""

# Example: Get recommendations for a popular anime
popular_anime_id = anime_in_ratings['anime_id'].value_counts().index[0]
popular_anime_name = anime_in_ratings[anime_in_ratings['anime_id'] == popular_anime_id]['name'].values[0]
print(f"Getting content-based recommendations for: {popular_anime_name} (ID: {popular_anime_id})")

content_recommendations = get_content_based_recommendations(popular_anime_id)
print("\nContent-based Recommendations:")
print(content_recommendations)

# Collaborative Filtering

# Set up the Surprise dataset
reader = Reader(rating_scale=(1, 10))
data = Dataset.load_from_df(rating_filtered[['user_id', 'anime_id', 'rating']], reader)

# Split into training and testing sets
trainset, testset = train_test_split(data, test_size=0.2, random_state=42)

# Build and train SVD model
svd_model = SVD(n_factors=100, random_state=42)
svd_model.fit(trainset)

# Evaluate model
predictions = svd_model.test(testset)
rmse = accuracy.rmse(predictions)
mae = accuracy.mae(predictions)

print(f"\nCollaborative Filtering Evaluation:")
print(f"RMSE: {rmse:.4f}")
print(f"MAE: {mae:.4f}")

# Function to get collaborative filtering recommendations
def get_collaborative_recommendations(user_id, anime_df=anime_in_ratings, rating_df=rating_filtered, model=svd_model, top_n=10):
    # Get anime the user has already watched
    watched_anime = rating_df[rating_df['user_id'] == user_id]['anime_id'].unique()

    # Get anime the user hasn't watched
    unwatched_anime = anime_df[~anime_df['anime_id'].isin(watched_anime)]['anime_id'].unique()

    # Limit to 100 anime for efficiency
    if len(unwatched_anime) > 100:
        unwatched_anime = np.random.choice(unwatched_anime, 100, replace=False)

    # Predict ratings for unwatched anime
    predictions = []
    for anime_id in unwatched_anime:
        predicted_rating = model.predict(user_id, anime_id).est
        predictions.append((anime_id, predicted_rating))

    # Sort by predicted rating
    predictions.sort(key=lambda x: x[1], reverse=True)

    # Get top N anime
    top_anime_ids = [anime_id for anime_id, _ in predictions[:top_n]]

    # Get anime information
    recommendations = anime_df[anime_df['anime_id'].isin(top_anime_ids)][['anime_id', 'name', 'genre', 'type', 'rating']]

    return recommendations

# Example: Get recommendations for a sample user
sample_user_id = rating_filtered['user_id'].value_counts().index[0]
print(f"\nGetting collaborative filtering recommendations for User ID: {sample_user_id}")

collaborative_recommendations = get_collaborative_recommendations(sample_user_id)
print("\nCollaborative Filtering Recommendations:")
print(collaborative_recommendations)

# Hybrid recommender system (combining both approaches)
def get_hybrid_recommendations(user_id, anime_id, weight_cf=0.7, weight_cb=0.3,
                               anime_df=anime_in_ratings, rating_df=rating_filtered,
                               model=svd_model, cosine_sim=cosine_sim, indices=indices):
    # Get collaborative filtering recommendations
    cf_recommendations = get_collaborative_recommendations(user_id, anime_df, rating_df, model, top_n=50)
    cf_anime_ids = cf_recommendations['anime_id'].tolist()

    # Get content-based recommendations
    cb_recommendations = get_content_based_recommendations(anime_id, cosine_sim, anime_df, indices)
    cb_anime_ids = cb_recommendations['anime_id'].tolist()

    # Combine recommendations with weights
    hybrid_scores = {}

    # Normalize ranking (1 is best)
    max_rank = max(len(cf_anime_ids), len(cb_anime_ids))

    # Score CF recommendations
    for i, anime_id in enumerate(cf_anime_ids):
        normalized_rank = 1 - (i / max_rank)
        hybrid_scores[anime_id] = weight_cf * normalized_rank

    # Score CB recommendations
    for i, anime_id in enumerate(cb_anime_ids):
        normalized_rank = 1 - (i / max_rank)
        if anime_id in hybrid_scores:
            hybrid_scores[anime_id] += weight_cb * normalized_rank
        else:
            hybrid_scores[anime_id] = weight_cb * normalized_rank

    # Sort by hybrid score
    sorted_anime = sorted(hybrid_scores.items(), key=lambda x: x[1], reverse=True)

    # Get top 10 anime
    top_anime_ids = [anime_id for anime_id, _ in sorted_anime[:10]]

    # Get anime information
    recommendations = anime_df[anime_df['anime_id'].isin(top_anime_ids)][['anime_id', 'name', 'genre', 'type', 'rating']]

    return recommendations

# Example: Get hybrid recommendations
print("\nGetting hybrid recommendations (combining collaborative and content-based)")
hybrid_recommendations = get_hybrid_recommendations(sample_user_id, popular_anime_id)
print("\nHybrid Recommendations:")
print(hybrid_recommendations)

# Save the models for future use
import pickle

# Save the SVD model
with open('svd_model.pkl', 'wb') as f:
    pickle.dump(svd_model, f)

# Save the cosine similarity matrix
with open('cosine_sim.pkl', 'wb') as f:
    pickle.dump(cosine_sim, f)

# Save the necessary dataframes and mappings
with open('recommendation_data.pkl', 'wb') as f:
    pickle.dump({
        'anime_in_ratings': anime_in_ratings,
        'indices': indices
    }, f)

print("\nModels and data saved for future use.")

"""Kedua pendekatan memiliki kelebihan dan kekurangan masing-masing:

1. Content-based Filtering unggul dalam:

Kemampuan menangani cold-start problem untuk anime baru
Transparansi dalam menjelaskan rekomendasi (berdasarkan kesamaan genre)
Tidak memerlukan data dari pengguna lain


Collaborative Filtering unggul dalam:

Akurasi prediksi rating yang lebih tinggi
Kemampuan menemukan preferensi implisit pengguna
Rekomendasi yang lebih personal dan bervariasi

##Evaluasi Kedua Pendekatan
Kedua pendekatan memiliki kelebihan dan kekurangan masing-masing:

1. Content-based Filtering unggul dalam:

- Kemampuan menangani cold-start problem untuk anime baru
- Transparansi dalam menjelaskan rekomendasi (berdasarkan kesamaan genre)
- Tidak memerlukan data dari pengguna lain


2. Collaborative Filtering unggul dalam:

- Akurasi prediksi rating yang lebih tinggi
- Kemampuan menemukan preferensi implisit pengguna
- Rekomendasi yang lebih personal dan bervariasi

##Kesimpulan dan Saran

**Kesimpulan**
Dalam proyek ini, kita telah berhasil mengembangkan sistem rekomendasi anime dengan dua pendekatan berbeda: Content-based Filtering dan Collaborative Filtering. Berikut adalah beberapa kesimpulan utama:

1. Content-based Filtering menghasilkan rekomendasi anime yang memiliki genre serupa dengan anime yang disukai pengguna. Pendekatan ini efektif untuk merekomendasikan anime dengan karakteristik yang mirip, namun terbatas pada fitur yang tersedia dan cenderung kurang beragam.
2. Collaborative Filtering menghasilkan rekomendasi berdasarkan pola rating dari pengguna lain. Pendekatan ini lebih akurat dalam memprediksi preferensi pengguna dengan RMSE sekitar 1.10-1.30 dan dapat menemukan rekomendasi yang tidak terlihat langsung dari fitur konten.
3. Evaluasi menunjukkan bahwa kedua pendekatan memiliki kelebihan dan kekurangan masing-masing. Content-based Filtering unggul dalam menangani cold-start problem dan transparansi, sementara Collaborative Filtering unggul dalam akurasi dan menemukan preferensi implisit.
4. Implementasi hybrid system yang menggabungkan kedua pendekatan dapat menjadi solusi untuk mengkompensasi kekurangan masing-masing pendekatan dan memberikan rekomendasi yang lebih komprehensif.

**Saran Pengembangan**
Berikut adalah beberapa saran untuk pengembangan sistem rekomendasi anime di masa depan:

1. Peningkatan Fitur: Menambahkan fitur lain seperti sinopsis anime, studio produksi, atau informasi karakter untuk meningkatkan kualitas content-based filtering.
2. Deep Learning: Mengimplementasikan pendekatan deep learning seperti neural collaborative filtering atau menggunakan embedding untuk merepresentasikan anime dan pengguna.
3. Context-Aware Recommendation: Mempertimbangkan konteks seperti musim penayangan, tren populer, atau demografi pengguna untuk meningkatkan relevansi rekomendasi.
4. Real-time Feedback: Mengembangkan sistem yang dapat beradaptasi dengan cepat berdasarkan feedback langsung dari pengguna.
5. Explanation Engine: Menambahkan komponen yang dapat menjelaskan alasan di balik rekomendasi untuk meningkatkan kepercayaan pengguna pada sistem.
6. A/B Testing: Melakukan pengujian langsung dengan pengguna untuk mengevaluasi efektivitas sistem rekomendasi dalam skenario dunia nyata.

Dengan pengembangan lebih lanjut, sistem rekomendasi anime ini dapat memberikan pengalaman yang lebih personal dan membantu pengguna menemukan anime yang sesuai dengan preferensi mereka dengan lebih efektif.
"""